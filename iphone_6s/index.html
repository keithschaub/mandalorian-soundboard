<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="Mandalorian">
    <title>Mandalorian Soundboard v5.7.3 - iPhone</title>
    <meta name="description" content="Ultra-simple Mandalorian soundboard for costume performances - Works offline">
    <link rel="manifest" href="manifest.json">
    <link rel="apple-touch-icon" href="icon-192.png">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: #1A1A1A;
            color: #C0C0C0;
            font-family: 'Arial Black', 'Arial', sans-serif;
            padding: 15px;
            min-height: 100vh;
            user-select: none;
            -webkit-user-select: none;
            -webkit-touch-callout: none;
            /* Prevent iOS bounce scrolling */
            position: fixed;
            width: 100%;
            height: 100%;
            overflow: hidden;
        }

        .app-title {
            text-align: center;
            font-size: 20px;
            font-weight: bold;
            margin: 5px 0 5px 0;
            color: #4A90E2;
            text-shadow: 0 0 10px rgba(74, 144, 226, 0.5);
            letter-spacing: 1px;
            flex-shrink: 0;
        }

        .sound-grid {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            gap: 8px;
            max-width: 100%;
            margin: 0 auto 10px auto;
            padding: 0 10px;
            overflow-y: auto;
            flex: 1 1 auto;
            min-height: 0;
            max-height: calc(100vh - 250px);
        }

        .sound-btn {
            width: 100%;
            aspect-ratio: 1;
            min-height: 70px;
            border-radius: 15px;
            border: 2px solid #4A90E2;
            background: linear-gradient(145deg, #2D2D2D, #1A1A1A);
            color: white;
            font-size: 9px;
            font-weight: bold;
            text-align: center;
            cursor: pointer;
            transition: all 0.1s ease;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            box-shadow: 0 3px 6px rgba(0,0,0,0.3);
            position: relative;
            overflow: hidden;
            -webkit-tap-highlight-color: transparent;
        }

        .sound-btn:hover {
            border-color: #5BA0F2;
            box-shadow: 0 6px 12px rgba(0,0,0,0.4);
        }

        .sound-btn:active {
            transform: scale(0.95);
            background: linear-gradient(145deg, #4A90E2, #357ABD);
            box-shadow: inset 0 2px 4px rgba(0,0,0,0.3);
        }

        .sound-btn.playing {
            background: linear-gradient(145deg, #00FF41, #00CC33);
            animation: pulse 0.5s ease-in-out;
        }

        .sound-btn.orange.playing {
            background: linear-gradient(145deg, #FF8C00, #FF7F00) !important;
            animation: pulse 0.5s ease-in-out;
        }

        .sound-btn.toggled-on {
            background: linear-gradient(145deg, rgba(255, 165, 0, 0.6), rgba(255, 140, 0, 0.4)) !important;
            box-shadow: 0 0 20px rgba(255, 165, 0, 0.9), inset 0 0 10px rgba(255, 165, 0, 0.4) !important;
            border: 4px solid rgba(255, 165, 0, 1) !important;
            animation: orange-glow 2s ease-in-out infinite alternate !important;
        }

        @keyframes orange-glow {
            from {
                box-shadow: 0 0 20px rgba(255, 165, 0, 0.9), inset 0 0 10px rgba(255, 165, 0, 0.4);
            }
            to {
                box-shadow: 0 0 35px rgba(255, 165, 0, 1), inset 0 0 20px rgba(255, 165, 0, 0.6);
            }
        }

        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }

        .btn-text {
            font-size: 16px;
            line-height: 1.0;
            text-transform: uppercase;
            letter-spacing: 0px;
            font-weight: 900;
            padding: 2px;
        }

        /* Color variants */
        .blue { border-color: #4A90E2; }
        .green { border-color: #00FF41; }
        .red { border-color: #FF4757; }
        .yellow { border-color: #FFD700; }
        .gray { border-color: #5A6C7D; }
        .orange { border-color: #FF6B35; }

        .volume-control {
            text-align: center;
            margin: 10px auto 10px auto;
            max-width: 400px;
            padding: 10px 15px;
            flex-shrink: 0;
            position: sticky;
            bottom: 0;
            z-index: 100;
            background: rgba(26, 26, 26, 0.98);
            border-top: 1px solid rgba(74, 144, 226, 0.3);
        }

        .volume-label {
            font-size: 18px;
            margin-bottom: 10px;
            color: #4A90E2;
        }

        .volume-slider {
            width: 100%;
            height: 12px;
            border-radius: 6px;
            background: #2D2D2D;
            outline: none;
            -webkit-appearance: none;
            appearance: none;
            touch-action: pan-x;
            -webkit-tap-highlight-color: transparent;
            cursor: pointer;
        }

        .volume-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 32px;
            height: 32px;
            border-radius: 50%;
            background: #4A90E2;
            cursor: pointer;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
            border: 2px solid #357ABD;
        }

        .volume-slider::-moz-range-thumb {
            width: 32px;
            height: 32px;
            border-radius: 50%;
            background: #4A90E2;
            cursor: pointer;
            border: 2px solid #357ABD;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        }

        /* Mobile optimizations */
        @media (max-width: 480px) {
            body {
                padding: 10px;
            }
            
            .sound-grid {
                grid-template-columns: repeat(4, 1fr);
                gap: 6px;
            }
            
            .sound-btn {
                min-height: 65px;
            }
            
            .btn-text {
                font-size: 14px;
                font-weight: 900;
                padding: 2px;
                line-height: 1.0;
            }
            
            .app-title {
                font-size: 18px;
                margin: 3px 0 3px 0;
            }
            
            .color-legend {
                margin: 3px auto 8px auto;
            }
            
            .volume-control {
                margin: 8px auto 15px auto;
            }
        }

        /* Landscape mode */
        @media (orientation: landscape) and (max-height: 500px) {
            body {
                padding: 8px;
            }
            
            .soundboard-screen {
                padding-bottom: 60px;
            }
            
            .sound-grid {
                grid-template-columns: repeat(10, 1fr);
                gap: 4px;
                max-height: calc(100vh - 180px);
            }
            
            .sound-btn {
                min-height: 50px;
            }
            
            .btn-text {
                font-size: 12px;
                font-weight: 900;
                padding: 1px;
                line-height: 1.0;
            }
            
            .app-title {
                font-size: 16px;
                margin: 3px 0 3px 0;
            }
            
            .color-legend {
                margin: 3px auto 5px auto;
            }
            
            .volume-control {
                margin: 5px auto 5px auto;
                padding: 8px 15px;
                position: sticky;
                bottom: 0;
            }
            
            .volume-slider {
                height: 14px;
            }
            
            .volume-slider::-webkit-slider-thumb {
                width: 36px;
                height: 36px;
            }
            
            .volume-slider::-moz-range-thumb {
                width: 36px;
                height: 36px;
            }
        }

        /* Loading state */
        .loading {
            opacity: 0.6;
            pointer-events: none;
        }

        /* Error state */
        .error {
            border-color: #FF4757;
            background: linear-gradient(145deg, #FF4757, #CC3A47);
        }

        /* Color legend */
        .color-legend {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 8px;
            margin: 5px auto 10px auto;
            max-width: 600px;
            flex-shrink: 0;
        }

        .legend-item {
            font-size: 12px;
            font-weight: bold;
            color: #C0C0C0;
            padding: 4px 8px;
            border-radius: 8px;
            background: rgba(45, 45, 45, 0.5);
        }

        /* Audio enable section */
        .audio-enable-section {
            text-align: center;
            margin: 40px auto;
            max-width: 400px;
        }

        .enable-audio-btn {
            background: linear-gradient(145deg, #4A90E2, #357ABD);
            border: 3px solid #4A90E2;
            border-radius: 20px;
            color: white;
            font-size: 24px;
            font-weight: bold;
            padding: 20px 40px;
            cursor: pointer;
            transition: all 0.2s ease;
            box-shadow: 0 6px 12px rgba(0,0,0,0.3);
            margin-bottom: 15px;
        }

        .enable-audio-btn:hover {
            background: linear-gradient(145deg, #5BA0F2, #4A90E2);
            transform: translateY(-2px);
            box-shadow: 0 8px 16px rgba(0,0,0,0.4);
        }

        .enable-audio-btn:active {
            transform: scale(0.95);
            box-shadow: inset 0 2px 4px rgba(0,0,0,0.3);
        }

        .audio-help {
            color: #C0C0C0;
            font-size: 14px;
            margin: 0;
            opacity: 0.8;
        }

        /* Offline indicator */
        .offline-indicator {
            position: fixed;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.8);
            color: #00FF41;
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 12px;
            z-index: 1000;
            display: none;
        }

        .offline-indicator.show {
            display: block;
        }

        /* Install prompt */
        .install-prompt {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(26, 26, 26, 0.95);
            border: 2px solid #4A90E2;
            border-radius: 15px;
            padding: 15px;
            color: #C0C0C0;
            font-size: 14px;
            text-align: center;
            z-index: 1000;
            display: none;
            max-width: 90%;
        }

        .install-prompt.show {
            display: block;
        }

        .install-prompt button {
            background: #4A90E2;
            color: white;
            border: none;
            border-radius: 8px;
            padding: 10px 20px;
            font-size: 16px;
            font-weight: bold;
            margin-top: 10px;
            cursor: pointer;
        }

        /* Radar Screen Styles */
        .radar-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #0a0a0a;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 2000;
            overflow: hidden;
        }

        .radar-container {
            position: relative;
            width: min(300px, 80vw);
            height: min(300px, 80vw);
            border-radius: 50%;
            background: radial-gradient(circle, rgba(0, 255, 0, 0.05) 0%, transparent 70%);
            border: 2px solid rgba(0, 255, 0, 0.3);
        }

        .radar-sweep {
            position: absolute;
            width: 83%;
            height: 2px;
            background: linear-gradient(90deg, transparent, rgba(0, 255, 0, 0.8), transparent);
            top: 50%;
            left: 50%;
            transform-origin: 0 0;
            animation: radar-sweep 3s linear infinite;
            box-shadow: 0 0 10px rgba(0, 255, 0, 0.5);
        }

        @keyframes radar-sweep {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .radar-rings {
            position: absolute;
            width: 100%;
            height: 100%;
            border-radius: 50%;
        }

        .ring {
            position: absolute;
            border: 1px solid rgba(0, 255, 0, 0.2);
            border-radius: 50%;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }

        .ring-1 { width: 33%; height: 33%; }
        .ring-2 { width: 66%; height: 66%; }
        .ring-3 { width: 100%; height: 100%; }
        .ring-4 { width: 133%; height: 133%; }
        .ring-5 { width: 166%; height: 166%; }

        .radar-center {
            position: absolute;
            width: 8px;
            height: 8px;
            background: #00ff00;
            border-radius: 50%;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            box-shadow: 0 0 10px rgba(0, 255, 0, 0.8);
            animation: pulse 2s ease-in-out infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; transform: translate(-50%, -50%) scale(1); }
            50% { opacity: 0.5; transform: translate(-50%, -50%) scale(1.2); }
        }

        .radar-text {
            position: absolute;
            bottom: 50px;
            left: 50%;
            transform: translateX(-50%);
            color: #ff0000;
            font-family: 'Courier New', monospace;
            font-size: 18px;
            font-weight: bold;
            text-shadow: 0 0 10px rgba(255, 0, 0, 0.8);
            animation: blink 2s ease-in-out infinite;
            white-space: nowrap;
        }

        @keyframes blink {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.3; }
        }

        /* Mandalorian Helmet Silhouette */
        .helmet-silhouette {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 60%;
            height: 60%;
            opacity: 0.15;
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'%3E%3Cpath d='M50 10 L30 25 L30 40 Q30 50 35 55 L35 70 Q35 75 40 75 L60 75 Q65 75 65 70 L65 55 Q70 50 70 40 L70 25 Z' fill='%2300ff00'/%3E%3Cpath d='M40 55 L40 65 L60 65 L60 55 Q50 60 40 55' fill='%2300ff00'/%3E%3Cpath d='M45 30 L45 40 L55 40 L55 30 Q50 25 45 30' fill='%2300ff00'/%3E%3C/svg%3E");
            background-size: contain;
            background-repeat: no-repeat;
            background-position: center;
            filter: drop-shadow(0 0 5px rgba(0, 255, 0, 0.3));
        }

        /* Radar Blips */
        .radar-blip {
            position: absolute;
            width: 6px;
            height: 6px;
            border-radius: 50%;
            animation: blip-fade 6s ease-out forwards;
        }

        .radar-blip.green {
            background: #00ff00;
            box-shadow: 0 0 8px rgba(0, 255, 0, 0.8);
        }

        .radar-blip.red {
            width: 32px;
            height: 32px;
            background: transparent;
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'%3E%3Cpath d='M50 8 L30 12 L20 25 L18 40 L22 55 L30 68 L40 75 L50 78 L60 75 L70 68 L78 55 L82 40 L80 25 L70 12 L50 8 Z' fill='%23ff0000'/%3E%3Cpath d='M38 42 L32 38 L28 42 L32 46 Z' fill='%23000000'/%3E%3Cpath d='M68 42 L72 38 L76 42 L72 46 Z' fill='%23000000'/%3E%3Cpath d='M35 58 L30 62 L35 66 L40 62 L45 66 L50 62 L55 66 L60 62 L65 66 L70 62 L65 58 L60 62 L55 58 L50 62 L45 58 L40 62 L35 58 Z' fill='%23000000'/%3E%3Cpath d='M50 78 L50 88 M35 82 L65 82' stroke='%23ff0000' stroke-width='4' stroke-linecap='round'/%3E%3Cpath d='M25 85 L75 85 M30 90 L70 90' stroke='%23ff0000' stroke-width='3' stroke-linecap='round'/%3E%3C/svg%3E");
            background-size: contain;
            background-repeat: no-repeat;
            background-position: center;
            border: none;
            outline: none;
            box-shadow: none;
        }

        /* Blip text labels */
        .blip-label {
            position: absolute;
            color: #00ff00;
            font-family: 'Courier New', monospace;
            font-size: 24px;
            font-weight: bold;
            text-shadow: 0 0 5px rgba(0, 255, 0, 0.8);
            white-space: nowrap;
            pointer-events: none;
            animation: blip-fade 6s ease-out forwards;
            transform: translateX(-50%);
        }

        @keyframes blip-fade {
            0% {
                opacity: 1;
                transform: scale(1);
            }
            100% {
                opacity: 0;
                transform: scale(0.5);
            }
        }

        /* Soundboard screen wrapper */
        .soundboard-screen {
            width: 100%;
            height: 100vh;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            padding-bottom: 80px; /* Account for browser UI at bottom */
            box-sizing: border-box;
            position: relative;
        }
    </style>
</head>
<body>
    <!-- Radar Screen -->
    <div id="radarScreen" class="radar-screen">
        <div class="radar-container">
            <div class="radar-rings">
                <div class="ring ring-1"></div>
                <div class="ring ring-2"></div>
                <div class="ring ring-3"></div>
                <div class="ring ring-4"></div>
                <div class="ring ring-5"></div>
            </div>
            <div class="helmet-silhouette"></div>
            <div class="radar-sweep"></div>
            <div class="radar-center"></div>
            <div class="radar-text">ENEMIES NEARBY</div>
        </div>
    </div>

    <!-- Soundboard Screen -->
    <div id="soundboardScreen" class="soundboard-screen" style="display: none;">
        <div class="offline-indicator" id="offlineIndicator">ðŸ“´ OFFLINE MODE</div>
        
        <h1 class="app-title">ðŸª– MANDALORIAN v5.7.3</h1>
    
    <div class="color-legend" id="colorLegend" style="display: flex;">
        <div class="legend-item">ðŸ”µ MANDO</div>
        <div class="legend-item">ðŸŸ¢ GROGU</div>
        <div class="legend-item">ðŸŸ  THEMES</div>
    </div>
    
    <div class="sound-grid" id="soundGrid" style="display: grid;">
        <!-- ORANGE = THEMES (Music) -->
        <button class="sound-btn orange" data-sound="Mando Theme">
            <div class="btn-text">MANDO<br>THEME</div>
        </button>
        
        <button class="sound-btn orange" data-sound="Mando Flute">
            <div class="btn-text">MANDO<br>FLUTE</div>
        </button>
        
        <!-- BLUE = MANDO (Din Djarin speaking) -->
        <button class="sound-btn blue" data-sound="This is the way">
            <div class="btn-text">THIS IS<br>THE WAY</div>
        </button>
        
        <button class="sound-btn blue" data-sound="I'm a Mandalorian">
            <div class="btn-text">I'M A<br>MANDO</div>
        </button>
        
        <button class="sound-btn blue" data-sound="No droids">
            <div class="btn-text">NO<br>DROIDS</div>
        </button>
        
        <button class="sound-btn blue" data-sound="Great">
            <div class="btn-text">GREAT</div>
        </button>
        
        <button class="sound-btn blue" data-sound="Thank you">
            <div class="btn-text">THANK<br>YOU</div>
        </button>
        
        <button class="sound-btn blue" data-sound="Yes">
            <div class="btn-text">YES</div>
        </button>
        
        <button class="sound-btn blue" data-sound="Don't touch anything">
            <div class="btn-text">DON'T<br>TOUCH</div>
        </button>
        
        <button class="sound-btn blue" data-sound="Do not self destruct">
            <div class="btn-text">NO SELF<br>DESTRUCT</div>
        </button>
        
        <button class="sound-btn blue" data-sound="I could use a crew">
            <div class="btn-text">NEED<br>CREW</div>
        </button>
        
        <button class="sound-btn blue" data-sound="I don't belong here">
            <div class="btn-text">DON'T<br>BELONG</div>
        </button>
        
        <button class="sound-btn blue" data-sound="Where do you live">
            <div class="btn-text">WHERE<br>LIVE?</div>
        </button>
        
        <button class="sound-btn blue" data-sound="Why so slow">
            <div class="btn-text">WHY SO<br>SLOW?</div>
        </button>
        
        <button class="sound-btn blue" data-sound="You want some soup">
            <div class="btn-text">WANT<br>SOUP?</div>
        </button>
        
        <!-- GREEN = GROGU (Baby Yoda sounds) -->
        <button class="sound-btn green" data-sound="Grogu Cooing">
            <div class="btn-text">GROGU<br>COO</div>
        </button>
        
        <button class="sound-btn green" data-sound="Grogu giggling">
            <div class="btn-text">GROGU<br>GIGGLE</div>
        </button>
        
        <button class="sound-btn green" data-sound="Grogu YES">
            <div class="btn-text">GROGU<br>YES</div>
        </button>
        
        <button class="sound-btn green" data-sound="Grogu NO">
            <div class="btn-text">GROGU<br>NO</div>
        </button>
        
        <button class="sound-btn green" data-sound="Grogu bad baby">
            <div class="btn-text">BAD<br>BABY</div>
        </button>
    </div>
    
        <div class="volume-control" id="volumeControl" style="display: block;">
            <div class="volume-label">ðŸ”Š VOLUME</div>
            <input type="range" class="volume-slider" id="volumeSlider" min="0" max="100" value="80">
        </div>
    </div>

    <script>
        // Simplified Audio management system with offline support
        class SoundBoard {
            constructor() {
                this.sounds = {};
                this.gainNodes = {}; // Store GainNodes for iOS volume control
                this.currentVolume = 0.8;
                this.audioEnabled = false;
                this.audioContext = null;
                this.currentlyPlaying = null;
                this.backgroundMusic = null;
                this.backgroundSounds = ['Mando Theme', 'Mando Flute'];
                this.problematicSounds = ['Thank you', 'Yes'];
                this.toggledThemes = {};
                this.offlineMode = false;
                this.isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;
                this.init();
            }

            init() {
                this.setupOfflineDetection();
                this.setupVolumeControl();
                this.setupButtons();
                this.checkServiceWorker();
                // Auto-enable audio on initialization
                this.enableAudio();
            }

            setupOfflineDetection() {
                window.addEventListener('online', () => {
                    this.offlineMode = false;
                    document.getElementById('offlineIndicator').classList.remove('show');
                });

                window.addEventListener('offline', () => {
                    this.offlineMode = true;
                    document.getElementById('offlineIndicator').classList.add('show');
                });

                // Check initial state
                if (!navigator.onLine) {
                    this.offlineMode = true;
                    document.getElementById('offlineIndicator').classList.add('show');
                }
            }

            checkServiceWorker() {
                if ('serviceWorker' in navigator) {
                    navigator.serviceWorker.ready.then(registration => {
                        console.log('Service Worker ready');
                        // Check if we're in offline mode
                        if (!navigator.onLine) {
                            this.offlineMode = true;
                            document.getElementById('offlineIndicator').classList.add('show');
                        }
                    });
                }
            }

            enableAudio() {
                try {
                    console.log('Starting audio enable process...');
                    
                    // Create AudioContext for iOS volume control
                    if (this.isIOS && !this.audioContext) {
                        this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                        console.log('[VOLUME DEBUG] iOS detected, created AudioContext for volume control');
                    }
                    
                    // Create a simple test audio to unlock iOS audio
                    const testAudio = new Audio();
                    testAudio.volume = 0.1;
                    
                    const testContext = new (window.AudioContext || window.webkitAudioContext)();
                    const oscillator = testContext.createOscillator();
                    const gainNode = testContext.createGain();
                    
                    oscillator.connect(gainNode);
                    gainNode.connect(testContext.destination);
                    
                    oscillator.frequency.setValueAtTime(440, testContext.currentTime);
                    oscillator.type = 'sine';
                    gainNode.gain.setValueAtTime(0.1, testContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, testContext.currentTime + 0.1);
                    
                    oscillator.start(testContext.currentTime);
                    oscillator.stop(testContext.currentTime + 0.1);
                    console.log('Test beep played for iOS unlock');
                    
                    setTimeout(() => {
                        this.preloadSounds();
                        this.audioEnabled = true;
                        console.log('Audio system enabled!');
                    }, 200);
                } catch (error) {
                    console.error('Failed to enable audio:', error);
                    alert('Audio initialization failed. Please try again.');
                }
            }

            showSoundboard() {
                // Soundboard UI is already visible, no need to show/hide elements
                // This function is kept for compatibility but does nothing now
            }

            setupVolumeControl() {
                // Simple, direct implementation based on standard HTML5 audio volume control pattern
                const self = this;
                
                const setupSlider = () => {
                    const volumeSlider = document.getElementById('volumeSlider');
                    if (!volumeSlider) {
                        console.log('[VOLUME DEBUG] Slider not found, retrying...');
                        setTimeout(setupSlider, 100);
                        return;
                    }
                    
                    console.log('[VOLUME DEBUG] Slider found! Setting up...');
                    console.log('[VOLUME DEBUG] Current volume:', self.currentVolume);
                    console.log('[VOLUME DEBUG] Sounds loaded:', Object.keys(self.sounds).length);
                    console.log('[VOLUME DEBUG] Slider value:', volumeSlider.value);
                    
                    // Test function to directly set volume
                    window.testVolume = function(vol) {
                        console.log('[VOLUME TEST] Setting volume to:', vol);
                        self.currentVolume = vol;
                        for (const soundId in self.sounds) {
                            const audio = self.sounds[soundId];
                            if (audio) {
                                audio.volume = vol;
                                console.log('[VOLUME TEST] Set', soundId, 'to', audio.volume);
                            }
                        }
                        if (self.currentlyPlaying) {
                            self.currentlyPlaying.volume = vol;
                            console.log('[VOLUME TEST] Set currently playing to', vol);
                        }
                    };
                    console.log('[VOLUME DEBUG] Test function available: window.testVolume(0.5)');
                    
                    // Simple event handler - directly update all audio elements
                    const inputHandler = async function() {
                        const sliderValue = parseFloat(this.value);
                        const newVolume = sliderValue / 100; // Convert 0-100 to 0-1
                        console.log('[VOLUME DEBUG] INPUT EVENT FIRED! Value:', sliderValue, 'Volume:', newVolume);
                        console.log('[VOLUME DEBUG] iOS:', self.isIOS);
                        
                        self.currentVolume = newVolume;
                        
                        // On iOS, use GainNode; otherwise use audio.volume
                        if (self.isIOS && self.audioContext) {
                            // Resume audio context if suspended
                            if (self.audioContext.state === 'suspended') {
                                try {
                                    await self.audioContext.resume();
                                    console.log('[VOLUME DEBUG] Audio context resumed');
                                } catch (e) {
                                    console.error('[VOLUME DEBUG] Failed to resume audio context:', e);
                                }
                            }
                            
                            // CRITICAL: Create MediaElementSource for all sounds on first slider touch
                            // This avoids creating them during playback which causes crackling
                            for (const soundId in self.sounds) {
                                const audio = self.sounds[soundId];
                                if (audio && !audio._mediaSourceCreated && audio.readyState >= 2) {
                                    try {
                                        // Ensure audio is paused
                                        audio.pause();
                                        audio.currentTime = 0;
                                        
                                        // Create MediaElementSource and GainNode
                                        const source = self.audioContext.createMediaElementSource(audio);
                                        const gainNode = self.audioContext.createGain();
                                        gainNode.gain.value = newVolume;
                                        source.connect(gainNode);
                                        gainNode.connect(self.audioContext.destination);
                                        self.gainNodes[soundId] = gainNode;
                                        audio._mediaSourceCreated = true;
                                        console.log(`[VOLUME DEBUG] Created GainNode for ${soundId} on slider touch, gain: ${gainNode.gain.value}`);
                                    } catch (e) {
                                        console.error(`[VOLUME DEBUG] Failed to create GainNode for ${soundId}:`, e);
                                    }
                                }
                            }
                            
                            // Update ALL GainNodes on iOS
                            let updatedCount = 0;
                            for (const soundId in self.gainNodes) {
                                const gainNode = self.gainNodes[soundId];
                                if (gainNode) {
                                    const audio = self.sounds[soundId];
                                    if (audio && self.backgroundMusic === audio) {
                                        gainNode.gain.value = newVolume * 0.7;
                                        console.log(`[VOLUME DEBUG] Updated background music GainNode for ${soundId} to ${gainNode.gain.value}`);
                                    } else {
                                        gainNode.gain.value = newVolume;
                                        console.log(`[VOLUME DEBUG] Updated GainNode for ${soundId} to ${gainNode.gain.value}`);
                                    }
                                    updatedCount++;
                                }
                            }
                            
                            // Also check currentlyPlaying and backgroundMusic by direct reference
                            if (self.currentlyPlaying) {
                                for (const soundId in self.sounds) {
                                    if (self.sounds[soundId] === self.currentlyPlaying && self.gainNodes[soundId]) {
                                        self.gainNodes[soundId].gain.value = newVolume;
                                        console.log(`[VOLUME DEBUG] Updated currently playing GainNode for ${soundId} to ${newVolume}`);
                                        break;
                                    }
                                }
                            }
                            
                            if (self.backgroundMusic) {
                                for (const soundId in self.sounds) {
                                    if (self.sounds[soundId] === self.backgroundMusic && self.gainNodes[soundId]) {
                                        self.gainNodes[soundId].gain.value = newVolume * 0.7;
                                        console.log(`[VOLUME DEBUG] Updated background music GainNode for ${soundId} to ${newVolume * 0.7}`);
                                        break;
                                    }
                                }
                            }
                            
                            console.log(`[VOLUME DEBUG] Updated ${updatedCount} GainNodes total`);
                        } else {
                            // Update ALL audio elements directly (non-iOS)
                            let updatedCount = 0;
                            for (const soundId in self.sounds) {
                                const audio = self.sounds[soundId];
                                if (audio && audio.volume !== undefined) {
                                    if (self.backgroundMusic === audio) {
                                        audio.volume = newVolume * 0.7;
                                        console.log('[VOLUME DEBUG] Updated background music:', soundId, 'to', audio.volume);
                                    } else {
                                        audio.volume = newVolume;
                                        updatedCount++;
                                    }
                                }
                            }
                            console.log('[VOLUME DEBUG] Updated', updatedCount, 'preloaded sounds');
                            
                            // Update currently playing
                            if (self.currentlyPlaying) {
                                const oldVol = self.currentlyPlaying.volume;
                                self.currentlyPlaying.volume = newVolume;
                                console.log('[VOLUME DEBUG] Updated currently playing from', oldVol, 'to', self.currentlyPlaying.volume);
                            } else {
                                console.log('[VOLUME DEBUG] No currently playing sound');
                            }
                            
                            // Update background music
                            if (self.backgroundMusic) {
                                const oldVol = self.backgroundMusic.volume;
                                self.backgroundMusic.volume = newVolume * 0.7;
                                console.log('[VOLUME DEBUG] Updated background music from', oldVol, 'to', self.backgroundMusic.volume);
                            } else {
                                console.log('[VOLUME DEBUG] No background music');
                            }
                        }
                    };
                    
                    volumeSlider.addEventListener('input', inputHandler);
                    console.log('[VOLUME DEBUG] Added input event listener');
                    
                    // Also handle change event
                    volumeSlider.addEventListener('change', function() {
                        console.log('[VOLUME DEBUG] CHANGE EVENT FIRED!');
                        inputHandler.call(this);
                    });
                    console.log('[VOLUME DEBUG] Added change event listener');
                    
                    // Test if slider is working
                    volumeSlider.addEventListener('mousedown', function() {
                        console.log('[VOLUME DEBUG] Mouse down on slider');
                    });
                    volumeSlider.addEventListener('touchstart', function() {
                        console.log('[VOLUME DEBUG] Touch start on slider');
                    });
                    
                    console.log('[VOLUME DEBUG] Volume slider setup complete');
                };
                
                setupSlider();
            }

            setupButtons() {
                const buttons = document.querySelectorAll('.sound-btn');
                console.log(`Setting up ${buttons.length} sound buttons`);
                
                buttons.forEach(button => {
                    button.addEventListener('click', (e) => {
                        e.preventDefault();
                        if (!this.audioEnabled) {
                            return;
                        }
                        const soundId = button.dataset.sound;
                        this.playSound(soundId, button);
                    });

                    button.addEventListener('touchstart', (e) => {
                        e.preventDefault();
                        button.style.transform = 'scale(0.95)';
                    });

                    button.addEventListener('touchend', (e) => {
                        e.preventDefault();
                        button.style.transform = 'scale(1)';
                        
                        if (this.audioEnabled) {
                            const soundId = button.dataset.sound;
                            this.playSound(soundId, button);
                        }
                    });
                });
            }

            preloadSounds() {
                const soundFiles = [
                    'Mando Theme', 'Mando Flute', 'This is the way', "I'm a Mandalorian",
                    'No droids', 'Great', 'Thank you', 'Yes', "Don't touch anything",
                    'Do not self destruct', 'I could use a crew', "I don't belong here",
                    'Where do you live', 'Why so slow', 'You want some soup',
                    'Grogu Cooing', 'Grogu giggling', 'Grogu YES', 'Grogu NO', 'Grogu bad baby'
                ];

                soundFiles.forEach(soundId => {
                    // Use relative path for offline support
                    const audio = new Audio(`Sounds/${soundId}.mp3`);
                    audio.preload = 'auto';
                    
                    // On iOS, set volume to 1.0 (we'll control via GainNode)
                    // On non-iOS, set volume normally
                    if (this.isIOS) {
                        audio.volume = 1.0;
                    } else {
                        audio.volume = this.currentVolume;
                    }
                    
                    this.sounds[soundId] = audio;
                    
                    if (this.problematicSounds.includes(soundId)) {
                        const duplicateAudio = new Audio(`Sounds/${soundId}.mp3`);
                        duplicateAudio.preload = 'auto';
                        
                        if (this.isIOS) {
                            duplicateAudio.volume = 1.0;
                        } else {
                            duplicateAudio.volume = this.currentVolume;
                        }
                        
                        this.sounds[soundId + '_duplicate'] = duplicateAudio;
                    }
                    
                    audio.addEventListener('error', (e) => {
                        console.error(`Failed to load: ${soundId}.mp3`, e);
                    });

                    audio.addEventListener('ended', () => {
                        if (this.currentlyPlaying === audio) {
                            this.currentlyPlaying = null;
                        }
                        if (this.backgroundMusic === audio) {
                            this.backgroundMusic = null;
                        }
                    });
                });

                console.log(`Preloading ${soundFiles.length} audio files...`);
            }

            playSound(soundId, buttonElement) {
                if (!this.audioEnabled) {
                    return;
                }

                try {
                    const isBackgroundSound = this.backgroundSounds.includes(soundId);

                    if (isBackgroundSound) {
                        if (this.toggledThemes[soundId]) {
                            this.stopBackgroundMusic();
                            this.toggledThemes[soundId] = false;
                            buttonElement.classList.remove('toggled-on');
                            
                            buttonElement.classList.add('playing');
                            setTimeout(() => {
                                buttonElement.classList.remove('playing');
                            }, 200);
                        } else {
                            Object.keys(this.toggledThemes).forEach(themeId => {
                                if (themeId !== soundId && this.toggledThemes[themeId]) {
                                    this.toggledThemes[themeId] = false;
                                    const otherButton = document.querySelector(`[data-sound="${themeId}"]`);
                                    if (otherButton) {
                                        otherButton.classList.remove('toggled-on');
                                    }
                                }
                            });
                            
                            this.toggledThemes[soundId] = true;
                            buttonElement.classList.add('toggled-on');
                            
                            if (this.sounds[soundId]) {
                                const audio = this.sounds[soundId];
                                this.playBackgroundMusicWithLoop(soundId, audio, buttonElement);
                            }
                        }
                    } else {
                        buttonElement.classList.add('playing');
                        setTimeout(() => {
                            buttonElement.classList.remove('playing');
                        }, 500);

                        this.stopCurrentSound();
                        
                        if (this.sounds[soundId]) {
                            const audio = this.sounds[soundId];
                            this.playRegularSound(soundId, audio, buttonElement);
                        } else {
                            console.error(`Sound not found: ${soundId}`);
                            this.showError(buttonElement);
                        }
                    }
                } catch (error) {
                    console.error(`Error playing sound: ${error.message}`);
                    this.showError(buttonElement);
                }
            }

            resetAudioToCleanState(audio) {
                // Reset audio to a known good state
                try {
                    audio.pause();
                    audio.currentTime = 0;
                    audio.loop = false;
                    // Small delay to ensure state is reset
                    return new Promise((resolve) => {
                        setTimeout(() => {
                            audio.pause();
                            audio.currentTime = 0;
                            resolve();
                        }, 50);
                    });
                } catch (error) {
                    console.error(`Error resetting audio state: ${error.message}`);
                    return Promise.resolve();
                }
            }
            
            stopBackgroundMusic(clearAllToggles = false) {
                if (this.backgroundMusic) {
                    try {
                        // CRITICAL: Stop audio completely before doing anything else
                        this.backgroundMusic.pause();
                        this.backgroundMusic.currentTime = 0;
                        this.backgroundMusic.loop = false;
                        
                        // Force stop by removing loop and resetting multiple times
                        if (this.backgroundMusic.loop) {
                            this.backgroundMusic.loop = false;
                        }
                        
                        // Multiple pauses to ensure audio is fully stopped
                        setTimeout(() => {
                            if (this.backgroundMusic) {
                                this.backgroundMusic.pause();
                                this.backgroundMusic.currentTime = 0;
                                this.backgroundMusic.loop = false;
                            }
                        }, 10);
                        
                        setTimeout(() => {
                            if (this.backgroundMusic) {
                                this.backgroundMusic.pause();
                                this.backgroundMusic.currentTime = 0;
                            }
                        }, 50);
                    } catch (error) {
                        console.error(`Error stopping background music: ${error.message}`);
                    }
                    this.backgroundMusic = null;
                }
                
                if (clearAllToggles) {
                    Object.keys(this.toggledThemes).forEach(themeId => {
                        this.toggledThemes[themeId] = false;
                        const themeButton = document.querySelector(`[data-sound="${themeId}"]`);
                        if (themeButton) {
                            themeButton.classList.remove('toggled-on');
                        }
                    });
                }
            }

            async playBackgroundMusicWithLoop(soundId, audio, buttonElement) {
                // Stop any existing background music first
                this.stopBackgroundMusic(false);
                
                // Wait longer to ensure previous audio is fully stopped
                await new Promise(resolve => setTimeout(resolve, 200));
                
                // Reset audio to clean state
                await this.resetAudioToCleanState(audio);
                
                // On iOS, MediaElementSource should already be created when slider was touched
                // Just update the GainNode volume if it exists
                if (this.isIOS && this.gainNodes[soundId]) {
                    // Update existing GainNode
                    this.gainNodes[soundId].gain.value = this.currentVolume * 0.7;
                } else if (!this.isIOS) {
                    // Set volume for non-iOS
                    audio.volume = this.currentVolume * 0.7;
                }
                
                // Ensure audio is in clean state before playing
                audio.pause();
                audio.currentTime = 0;
                audio.loop = false;
                
                // Small delay before playing
                await new Promise(resolve => setTimeout(resolve, 50));
                
                // Play audio
                this.startBackgroundMusicPlayback(audio, soundId, buttonElement);
            }
            
            startBackgroundMusicPlayback(audio, soundId, buttonElement) {
                audio.currentTime = 0;
                audio.loop = true;
                
                const playPromise = audio.play();
                if (playPromise !== undefined) {
                    playPromise.then(() => {
                        this.backgroundMusic = audio;
                        console.log(`Background music playing: ${soundId}`);
                    }).catch(error => {
                        console.error(`Background music failed: ${error.message}`);
                        this.backgroundMusic = null;
                        this.toggledThemes[soundId] = false;
                        buttonElement.classList.remove('toggled-on');
                        this.showError(buttonElement);
                    });
                }
            }
            

            playRegularSound(soundId, audio, buttonElement) {
                const isProblematic = this.problematicSounds.includes(soundId);
                let audioToUse = audio;
                
                if (isProblematic && this.backgroundMusic) {
                    const duplicateKey = soundId + '_duplicate';
                    if (this.sounds[duplicateKey]) {
                        audioToUse = this.sounds[duplicateKey];
                    }
                }
                
                const baseDelay = this.backgroundMusic ? 150 : 50;
                const delay = isProblematic ? baseDelay + 50 : baseDelay;
                
                setTimeout(() => {
                    this.attemptPlayRegularSound(soundId, audioToUse, buttonElement, isProblematic);
                }, delay);
            }

            async attemptPlayRegularSound(soundId, audio, buttonElement, isProblematic) {
                // Reset audio to clean state
                await this.resetAudioToCleanState(audio);
                
                // On iOS, MediaElementSource should already be created when slider was touched
                // Just update the GainNode volume if it exists
                if (this.isIOS && this.gainNodes[soundId]) {
                    // Update existing GainNode
                    this.gainNodes[soundId].gain.value = this.currentVolume;
                } else if (!this.isIOS) {
                    // Set volume for non-iOS
                    audio.volume = this.currentVolume;
                }
                
                // Ensure audio is in clean state before playing
                audio.pause();
                audio.currentTime = 0;
                
                // Small delay before playing
                await new Promise(resolve => setTimeout(resolve, 50));
                
                // Play audio
                const playPromise = audio.play();
                if (playPromise !== undefined) {
                    playPromise.then(() => {
                        this.currentlyPlaying = audio;
                        console.log(`Playing: ${soundId}`);
                    }).catch(error => {
                        console.error(`Play failed: ${error.message}`);
                        this.currentlyPlaying = null;
                        this.showError(buttonElement);
                    });
                }
            }

            stopCurrentSound() {
                if (this.currentlyPlaying) {
                    try {
                        this.currentlyPlaying.pause();
                        this.currentlyPlaying.currentTime = 0;
                    } catch (error) {
                        console.error(`Error stopping sound: ${error.message}`);
                    }
                    this.currentlyPlaying = null;
                }
            }

            updateAllVolumes() {
                // On iOS, update GainNodes; otherwise update audio.volume
                if (this.isIOS && this.audioContext) {
                    // Update all GainNodes
                    for (const soundId in this.gainNodes) {
                        const gainNode = this.gainNodes[soundId];
                        if (gainNode) {
                            const audio = this.sounds[soundId];
                            if (audio && this.backgroundMusic === audio) {
                                gainNode.gain.value = this.currentVolume * 0.7;
                            } else {
                                gainNode.gain.value = this.currentVolume;
                            }
                        }
                    }
                } else {
                    // Update all preloaded sounds (non-iOS)
                    Object.values(this.sounds).forEach(audio => {
                        if (audio && typeof audio.volume !== 'undefined') {
                            if (this.backgroundMusic === audio) {
                                audio.volume = this.currentVolume * 0.7;
                            } else {
                                audio.volume = this.currentVolume;
                            }
                        }
                    });
                    
                    // CRITICAL: Update currently playing sound immediately
                    if (this.currentlyPlaying && typeof this.currentlyPlaying.volume !== 'undefined') {
                        this.currentlyPlaying.volume = this.currentVolume;
                    }
                    
                    // CRITICAL: Update background music immediately
                    if (this.backgroundMusic && typeof this.backgroundMusic.volume !== 'undefined') {
                        this.backgroundMusic.volume = this.currentVolume * 0.7;
                    }
                }
            }

            showError(buttonElement) {
                buttonElement.classList.add('error');
                setTimeout(() => {
                    buttonElement.classList.remove('error');
                }, 1000);
            }
        }

        // Initialize the soundboard when page loads
        document.addEventListener('DOMContentLoaded', () => {
            window.soundBoard = new SoundBoard();
        });

        // Prevent zoom on double tap (iOS)
        let lastTouchEnd = 0;
        document.addEventListener('touchend', function (event) {
            const now = (new Date()).getTime();
            if (now - lastTouchEnd <= 300) {
                event.preventDefault();
            }
            lastTouchEnd = now;
        }, false);

        // Radar Screen Functionality
        let radarActive = true;
        let inactivityTimer = null;
        let blipInterval = null;
        const INACTIVITY_TIMEOUT = 30000; // 30 seconds to return to radar
        let activeBlips = { green: 0, red: 0 };
        const MAX_GREEN_BLIPS = 7;
        const MAX_RED_BLIPS = 4;
        const SWEEP_DURATION = 3000; // 3 seconds for full rotation
        let radarStartTime = Date.now();
        const AVAILABLE_NAMES = ['Luke', 'Ahsoka', 'Boba', 'Grogu', 'Leo', 'Sexy Bo-Katan', 'Greef', 'Fennec', 'Cara', 'IG-11', 'Kuiil'];
        let activeNames = new Set(); // Track which names are currently displayed

        // Get current radar sweep angle (0 to 2Ï€)
        function getCurrentSweepAngle() {
            const elapsed = (Date.now() - radarStartTime) % SWEEP_DURATION;
            return (elapsed / SWEEP_DURATION) * Math.PI * 2;
        }

        // Calculate when sweep will reach a given angle
        function getTimeUntilSweepReachesAngle(targetAngle) {
            const currentAngle = getCurrentSweepAngle();
            let angleDiff = targetAngle - currentAngle;
            
            // Normalize angle difference to 0-2Ï€ range
            if (angleDiff < 0) angleDiff += Math.PI * 2;
            
            // Convert angle difference to time (sweep rotates 2Ï€ in SWEEP_DURATION ms)
            const timeUntilReach = (angleDiff / (Math.PI * 2)) * SWEEP_DURATION;
            
            return timeUntilReach;
        }

        function createBlip(isRed = false, targetAngle = null) {
            const radarContainer = document.querySelector('.radar-container');
            if (!radarContainer || !radarActive) return;

            const color = isRed ? 'red' : 'green';
            const maxBlips = isRed ? MAX_RED_BLIPS : MAX_GREEN_BLIPS;
            
            // Don't create if we already have enough of this color
            if (activeBlips[color] >= maxBlips) return;

            const blip = document.createElement('div');
            blip.className = `radar-blip ${color}`;
            
            // Random position within radar circle (can extend beyond visible area)
            const angle = targetAngle !== null ? targetAngle : (Math.random() * Math.PI * 2);
            // Use power distribution to favor outer circles (ensures blips appear in all 5 circles)
            // Ring 1: 16.5% radius, Ring 2: 33% radius, Ring 3: 50% radius, Ring 4: 66.5% radius, Ring 5: 83% radius
            // To reach Ring 5 (83% radius), we need distance * 50 = 83, so distance = 1.66
            // Using 0.05 to 1.9 range to ensure we reach all 5 rings and even go slightly beyond
            const distance = Math.pow(Math.random(), 0.5) * 1.85 + 0.05; // 5% to 190% from center, biased toward outer areas
            const centerX = 50;
            const centerY = 50;
            
            const x = centerX + Math.cos(angle) * distance * 50;
            const y = centerY + Math.sin(angle) * distance * 50;
            
            blip.style.left = x + '%';
            blip.style.top = y + '%';
            
            // Check if we should add a text label for green blips (50% chance - increased since we have more names)
            let shouldAddLabel = false;
            let labelName = null;
            if (!isRed && Math.random() < 0.5) {
                // Get available names (not currently displayed)
                const availableNames = AVAILABLE_NAMES.filter(name => !activeNames.has(name));
                
                // Only add label if there are available names
                if (availableNames.length > 0) {
                    shouldAddLabel = true;
                    labelName = availableNames[Math.floor(Math.random() * availableNames.length)];
                }
            }
            
            // Calculate when sweep will reach this angle, then show blip slightly after
            const timeUntilSweep = getTimeUntilSweepReachesAngle(angle);
            const delayAfterSweep = 50; // 50ms after sweep passes (looks like it was just detected)
            const totalDelay = timeUntilSweep + delayAfterSweep;
            
            // If delay is too long (more than one rotation), show it in next rotation
            const finalDelay = totalDelay > SWEEP_DURATION ? totalDelay - SWEEP_DURATION : totalDelay;
            
            setTimeout(() => {
                if (radarActive && activeBlips[color] < maxBlips) {
                    radarContainer.appendChild(blip);
                    activeBlips[color]++;

                    // Add text label for green blips occasionally
                    if (shouldAddLabel && labelName) {
                        // Mark this name as active
                        activeNames.add(labelName);
                        
                        const label = document.createElement('div');
                        label.className = 'blip-label';
                        label.textContent = labelName;
                        // Position label above the blip using the same x coordinate
                        label.style.left = x + '%';
                        label.style.top = (y - 2) + '%'; // 2% above the blip
                        radarContainer.appendChild(label);
                        
                        // Remove label after animation (same as blip)
                        setTimeout(() => {
                            if (label.parentNode) {
                                label.parentNode.removeChild(label);
                            }
                            // Remove name from active set
                            activeNames.delete(labelName);
                        }, 6000);
                    }

                    // Remove blip after animation
                    setTimeout(() => {
                        if (blip.parentNode) {
                            blip.parentNode.removeChild(blip);
                            activeBlips[color]--;
                        }
                    }, 6000);
                }
            }, Math.max(0, finalDelay));
        }

        function startBlips() {
            if (blipInterval) clearInterval(blipInterval);
            radarStartTime = Date.now(); // Reset sweep timing
            
            // Create initial blips synchronized with sweep
            for (let i = 0; i < 5; i++) {
                const angle = Math.random() * Math.PI * 2;
                createBlip(false, angle); // Green blips
            }
            for (let i = 0; i < 3; i++) {
                const angle = Math.random() * Math.PI * 2;
                createBlip(true, angle); // Red blips
            }
            
            // Continue creating blips periodically, synchronized with sweep
            blipInterval = setInterval(() => {
                if (radarActive) {
                    // Create blip at random angle (will be synchronized with sweep)
                    const angle = Math.random() * Math.PI * 2;
                    
                    // Create green blip (more common)
                    if (Math.random() > 0.3) { // 70% chance for green
                        createBlip(false, angle);
                    } else { // 30% chance for red
                        createBlip(true, angle);
                    }
                }
            }, 600); // Check every 0.6 seconds for new blips
        }

        function showRadar() {
            document.getElementById('radarScreen').style.display = 'flex';
            document.getElementById('soundboardScreen').style.display = 'none';
            radarActive = true;
            radarStartTime = Date.now(); // Reset sweep timing
            activeNames.clear(); // Clear active names when radar resets
            startBlips();
            clearTimeout(inactivityTimer);
        }

        function showSoundboard() {
            document.getElementById('radarScreen').style.display = 'none';
            document.getElementById('soundboardScreen').style.display = 'block';
            radarActive = false;
            if (blipInterval) {
                clearInterval(blipInterval);
                blipInterval = null;
            }
            resetInactivityTimer();
            
            // Auto-enable audio if not already enabled
            if (window.soundBoard && !window.soundBoard.audioEnabled) {
                window.soundBoard.enableAudio();
            }
        }

        function resetInactivityTimer() {
            clearTimeout(inactivityTimer);
            inactivityTimer = setTimeout(() => {
                showRadar();
            }, INACTIVITY_TIMEOUT);
        }

        // Initialize radar on page load
        document.addEventListener('DOMContentLoaded', () => {
            // DEBUG: Allow bypassing radar screen with keyboard
            document.addEventListener('keydown', (e) => {
                if (e.key === 's' || e.key === 'S') {
                    console.log('[DEBUG] Bypassing radar screen');
                    showSoundboard();
                }
            });
            
            // DEBUG: Allow bypassing radar screen with double-click
            let clickCount = 0;
            let clickTimer = null;
            document.getElementById('radarScreen').addEventListener('click', (e) => {
                clickCount++;
                if (clickTimer) clearTimeout(clickTimer);
                clickTimer = setTimeout(() => {
                    if (clickCount >= 2) {
                        console.log('[DEBUG] Double-click detected, bypassing radar screen');
                        showSoundboard();
                    }
                    clickCount = 0;
                }, 300);
            });
            
            // Start blips
            startBlips();
            
            // Touch radar screen to activate soundboard
            document.getElementById('radarScreen').addEventListener('touchstart', (e) => {
                e.preventDefault();
                showSoundboard();
            });
            
            // Reset inactivity timer on any soundboard interaction
            document.addEventListener('touchstart', () => {
                if (!radarActive) {
                    resetInactivityTimer();
                }
            }, { passive: true });
        });

        // Service Worker registration for PWA functionality
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', () => {
                navigator.serviceWorker.register('sw.js')
                    .then(registration => {
                        console.log('Service Worker registered:', registration);
                    })
                    .catch(error => {
                        console.error('Service Worker registration failed:', error);
                    });
            });
        }
    </script>
</body>
</html>

